<template>
  <div class="h-full flex flex-col p-6 overflow-hidden relative">
    <div v-show="!drawerVisible" class="h-full flex flex-col overflow-y-auto">
      <header class="h-16 bg-white rounded-lg flex items-center justify-between px-6 mb-8 shrink-0">
        <h2 class="text-2xl font-semibold">Notes</h2>
        <div class="flex items-center space-x-2">
          <el-input placeholder="搜索..." :prefix-icon="Search" class="w-60" />
          <el-button :icon="Plus" type="primary" @click="handleCreateNote"> 新建 </el-button>
        </div>
      </header>

      <div
        class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 overflow-y-auto pb-4"
      >
        <ItemCard
          v-for="note in notes"
          :key="note.id"
          :item="note"
          @openDialog="(command, item) => handleViewNote(item.id)"
          @delete="handleDeleteNote"
          @togglePin="handleTogglePin"
        />
      </div>
      <el-empty v-if="notes.length === 0" description="暂无笔记" />
    </div>

    <transition name="el-fade-in-linear">
      <div
        v-if="drawerVisible"
        class="absolute inset-0 z-50 bg-white flex flex-col shadow-lg overflow-hidden border border-gray-200"
      >
        <div class="h-14 flex items-center justify-between px-4 border-b border-gray-200 shrink-0">
          <div class="flex items-center flex-1 mr-4">
            <input
              v-model="editTitle"
              class="bg-transparent text-lg font-bold text-gray-800 placeholder-gray-400 focus:outline-none w-full"
              placeholder="请输入标题..."
            />
          </div>
          <div class="flex items-center space-x-3">
            <span class="text-xs text-gray-400" v-if="isUnsaved">未保存</span>
            <el-button @click="handleSave" type="primary" size="small">保存</el-button>
            <el-button circle :icon="Close" size="small" @click="handleCloseEditor" />
          </div>
        </div>

        <div class="flex-1 flex overflow-hidden">
          <div class="w-1/2 h-full border-r border-gray-200 flex flex-col">
            <textarea
              v-model="editContent"
              class="w-full h-full p-6 resize-none focus:outline-none text-gray-700 leading-relaxed font-mono text-sm"
              placeholder="在此输入 Markdown 内容..."
            ></textarea>
          </div>

          <div class="w-1/2 h-full bg-white overflow-y-auto p-8">
            <div class="prose prose-slate max-w-none" v-html="renderMarkdown(editContent)"></div>
          </div>
        </div>
      </div>
    </transition>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch, nextTick, onMounted } from 'vue';
import { ElMessage, ElMessageBox } from 'element-plus';
// 假设 mockData 导出了这些函数
import { getItems, createItem, updateItem, deleteItem, getItemById } from '@/store/mockData';
import ItemCard from '@/components/ItemCard.vue';
import { Search, Plus, Close } from '@element-plus/icons-vue';
import { marked } from 'marked';

const notesRef = getItems('note');

const notes = computed(() =>
  notesRef.value.slice().sort((a, b) => Number(b.isPinned) - Number(a.isPinned))
);

// 状态管理
const drawerVisible = ref(false);
const currentNoteId = ref<number | null>(null);
const editTitle = ref('');
const editContent = ref('');
const isUnsaved = ref(false);

// 集中处理数据刷新(不再需要)
// 因为 notesRef 是一个 computed 引用，只要 mockData 中的 items.value 变化，
// notesRef.value 就会自动更新，从而 notes 也会自动更新。
// 所以可以移除 refreshNotes 函数，让 Vue 的响应式系统接管。
// const refreshNotes = () => {
// 强制重新从 mockData 中获取最新的数据数组
//   notesRaw.value = getItems('note');
// };

// 确保初始加载时数据存在（尽管 mockData 理论上应该在顶层加载）
// onMounted(() => {
//   refreshNotes();
// });

// 获取当前笔记数据的引用
const currentNote = computed(() => {
  if (currentNoteId.value === null) return null;
  const itemRef = getItemById(currentNoteId.value);
  // 确保找到了笔记对象 (itemRef.value 才是实际对象)
  return itemRef.value ? itemRef.value : null;
});

// 监听输入，判断是否需要保存
watch([editTitle, editContent], ([newTitle, newContent]) => {
  if (currentNote.value) {
    const originalTitle = currentNote.value.title;
    const originalContent = currentNote.value.content;
    if (newTitle !== originalTitle || newContent !== originalContent) {
      isUnsaved.value = true;
    } else {
      isUnsaved.value = false;
    }
  }
});

// 渲染 Markdown
const renderMarkdown = (md: string) => {
  return md ? marked.parse(md) : '<p class="text-gray-400 italic">空内容...</p>';
};

// 打开笔记（查看/编辑）
const handleViewNote = (id: number) => {
  const targetNote = getItemById(id).value;
  if (targetNote) {
    // 关键：如果找到了笔记，就打开
    currentNoteId.value = id;
    editTitle.value = targetNote.title;
    editContent.value = targetNote.content;
    isUnsaved.value = false;
    drawerVisible.value = true;
  } else {
    // 如果点卡片打不开，这里会提示错误
    ElMessage.error('无法找到该笔记，可能数据已损坏或丢失。');
  }
};

// 关闭编辑器
const handleCloseEditor = () => {
  const close = () => {
    drawerVisible.value = false;
    currentNoteId.value = null;
  };

  if (isUnsaved.value) {
    ElMessageBox.confirm('有未保存的更改，确定要关闭吗？更改将丢失。', '提示', {
      confirmButtonText: '强制关闭',
      cancelButtonText: '取消',
      type: 'warning',
    })
      .then(() => {
        close();
      })
      .catch(() => {});
  } else {
    close();
  }
};

// 新建笔记
const handleCreateNote = async () => {
  const newId = Date.now();
  const newNoteData = {
    id: newId,
    type: 'note' as const,
    title: '未命名笔记',
    content: '',
    tags: [] as string[],
    priority: 'medium' as const,
    status: 'done' as const,
    created_at: new Date().toISOString(),
    isPinned: false,
  };

  createItem(newNoteData);

  currentNoteId.value = newId;
  editTitle.value = newNoteData.title;
  editContent.value = newNoteData.content;

  drawerVisible.value = true;
  isUnsaved.value = false;

  await nextTick();
};

// 保存逻辑
const handleSave = () => {
  if (currentNoteId.value) {
    const titleToSave = editTitle.value.trim() || '未命名笔记';
    const updatedData = {
      title: titleToSave,
      content: editContent.value,
    };

    updateItem(currentNoteId.value, updatedData);

    if (editTitle.value !== titleToSave) {
      editTitle.value = titleToSave;
    }

    ElMessage.success('保存成功');
    isUnsaved.value = false;
  }
};

// 删除逻辑
const handleDeleteNote = (id: number) => {
  ElMessageBox.confirm('确定删除该笔记吗？', '警告', { type: 'warning' })
    .then(() => {
      if (currentNoteId.value === id) {
        drawerVisible.value = false;
        currentNoteId.value = null;
      }
      deleteItem(id);
      ElMessage.success('删除成功');
    })
    .catch(() => {});
};

// 置顶逻辑
const handleTogglePin = (id: number) => {
  const item = getItemById(id).value;
  if (!item) return;
  updateItem(id, { isPinned: !item.isPinned });
};
</script>

<style scoped>
/* 定义滚动条样式，让编辑器和预览区看起来更精致 */
textarea::-webkit-scrollbar,
.overflow-y-auto::-webkit-scrollbar {
  width: 6px;
}
textarea::-webkit-scrollbar-track,
.overflow-y-auto::-webkit-scrollbar-track {
  background: transparent;
}
textarea::-webkit-scrollbar-thumb,
.overflow-y-auto::-webkit-scrollbar-thumb {
  background-color: #e5e7eb;
  border-radius: 3px;
}
textarea::-webkit-scrollbar-thumb:hover,
.overflow-y-auto::-webkit-scrollbar-thumb:hover {
  background-color: #d1d5db;
}

/* 简单的 Prose 样式覆盖 (如果你没有安装 @tailwindcss/typography 插件) */
.prose h1 {
  font-size: 2em;
  font-weight: bold;
  margin-bottom: 0.5em;
}
.prose h2 {
  font-size: 1.5em;
  font-weight: bold;
  margin-top: 1em;
  margin-bottom: 0.5em;
  border-bottom: 1px solid #eee;
  padding-bottom: 0.3em;
}
.prose h3 {
  font-size: 1.25em;
  font-weight: bold;
  margin-top: 1em;
  margin-bottom: 0.5em;
}
.prose p {
  margin-bottom: 1em;
  line-height: 1.6;
}
.prose ul {
  list-style-type: disc;
  padding-left: 1.5em;
  margin-bottom: 1em;
}
.prose ol {
  list-style-type: decimal;
  padding-left: 1.5em;
  margin-bottom: 1em;
}
.prose blockquote {
  border-left: 4px solid #e5e7eb;
  padding-left: 1em;
  color: #6b7280;
  font-style: italic;
}
.prose pre {
  background: #f3f4f6;
  padding: 1em;
  border-radius: 0.5em;
  overflow-x: auto;
  font-family: monospace;
}
.prose code {
  background: #f3f4f6;
  padding: 0.2em 0.4em;
  border-radius: 0.25em;
  font-family: monospace;
  font-size: 0.9em;
}
.prose img {
  max-width: 100%;
  border-radius: 0.5em;
}
.prose a {
  color: #3b82f6;
  text-decoration: underline;
}
</style>
